/* tslint:disable */
/* eslint-disable */
/**
 * DVP
 * API for the Digital Verification Platform
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';
import { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BaseAPI, BASE_PATH, RequestArgs } from './base';

/**
 * Create keypair request payload containing
 * @export
 * @interface CreateKeyPairRequest
 */
export interface CreateKeyPairRequest {
  /**
   * key pair name, should be unique
   * @type {string}
   * @memberof CreateKeyPairRequest
   */
  name: string;
}
/**
 * Create keypair response containing the public key in plain text
 * @export
 * @interface CreateKeyPairResponse
 */
export interface CreateKeyPairResponse {
  /**
   * key pair id
   * @type {string}
   * @memberof CreateKeyPairResponse
   */
  keyId: string;
  /**
   * key pair name
   * @type {string}
   * @memberof CreateKeyPairResponse
   */
  name: string;
  /**
   * plaintext public key
   * @type {string}
   * @memberof CreateKeyPairResponse
   */
  publicKey: string;
}
/**
 * A JSON-LD Verifiable Credential without a proof.
 * @export
 * @interface Credential
 */
export interface Credential {
  [key: string]: any;

  /**
   * The JSON-LD context of the credential.
   * @type {Array<string>}
   * @memberof Credential
   */
  '@context': Array<string>;
  /**
   * The ID of the credential.
   * @type {string}
   * @memberof Credential
   */
  id?: string;
  /**
   * The JSON-LD type of the credential.
   * @type {Array<string>}
   * @memberof Credential
   */
  type: Array<string>;
  /**
   * The issuanceDate
   * @type {string}
   * @memberof Credential
   */
  issuanceDate: string;
  /**
   * The expirationDate
   * @type {string}
   * @memberof Credential
   */
  expirationDate?: string;
  /**
   * The subject
   * @type {object}
   * @memberof Credential
   */
  credentialSubject: object;
  /**
   *
   * @type {Issuer}
   * @memberof Credential
   */
  issuer: Issuer;
}
/**
 * An object containing the type and status of a verifiable credential
 * @export
 * @interface CredentialStatus
 */
export interface CredentialStatus {
  /**
   * Describes the revocation version to be used.
   * @type {string}
   * @memberof CredentialStatus
   */
  type: CredentialStatusTypeEnum;
  /**
   * Describes whether the status is revoked (1) or not revoked (0).
   * @type {string}
   * @memberof CredentialStatus
   */
  status: CredentialStatusStatusEnum;
}

export const CredentialStatusTypeEnum = {
  RevocationList2020Status: 'RevocationList2020Status',
  OpenAttestationOcsp: 'OpenAttestationOCSP',
} as const;

export type CredentialStatusTypeEnum =
  typeof CredentialStatusTypeEnum[keyof typeof CredentialStatusTypeEnum];
export const CredentialStatusStatusEnum = {
  _0: '0',
  _1: '1',
} as const;

export type CredentialStatusStatusEnum =
  typeof CredentialStatusStatusEnum[keyof typeof CredentialStatusStatusEnum];

/**
 * List of issued credentials
 * @export
 * @interface CredentialsResponse
 */
export interface CredentialsResponse {
  /**
   *
   * @type {Array<CredentialsResponseItem>}
   * @memberof CredentialsResponse
   */
  results?: Array<CredentialsResponseItem>;
  /**
   *
   * @type {Pagination}
   * @memberof CredentialsResponse
   */
  pagination?: Pagination;
}
/**
 * issued credential metadata
 * @export
 * @interface CredentialsResponseItem
 */
export interface CredentialsResponseItem {
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  documentNumber?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  freeTradeAgreement?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  importingJurisdiction?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  exporterOrManufacturerAbn?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  importerName?: string;
  /**
   *
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  consignmentReferenceNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof CredentialsResponseItem
   */
  documentDeclaration?: boolean;
  /**
   * The issue date
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  issueDate?: string;
  /**
   * The expiry date
   * @type {string}
   * @memberof CredentialsResponseItem
   */
  expiryDate?: string;
}
/**
 * List of document schemas
 * @export
 * @interface DocumentSchemasResponse
 */
export interface DocumentSchemasResponse {
  /**
   *
   * @type {Array<DocumentSchemasResponseItem>}
   * @memberof DocumentSchemasResponse
   */
  results?: Array<DocumentSchemasResponseItem>;
  /**
   *
   * @type {Pagination}
   * @memberof DocumentSchemasResponse
   */
  pagination?: Pagination;
}
/**
 * Document schema
 * @export
 * @interface DocumentSchemasResponseItem
 */
export interface DocumentSchemasResponseItem {
  /**
   * document schema name
   * @type {string}
   * @memberof DocumentSchemasResponseItem
   */
  name?: string;
  /**
   * document schema type
   * @type {string}
   * @memberof DocumentSchemasResponseItem
   */
  type?: DocumentSchemasResponseItemTypeEnum;
}

export const DocumentSchemasResponseItemTypeEnum = {
  Full: 'full',
  Partial: 'partial',
} as const;

export type DocumentSchemasResponseItemTypeEnum =
  typeof DocumentSchemasResponseItemTypeEnum[keyof typeof DocumentSchemasResponseItemTypeEnum];

/**
 *
 * @export
 * @interface DocumentUploadRequest
 */
export interface DocumentUploadRequest {
  /**
   * strigified document to upload
   * @type {string}
   * @memberof DocumentUploadRequest
   */
  document: string;
  /**
   *
   * @type {string}
   * @memberof DocumentUploadRequest
   */
  documentId?: string;
  /**
   * Key used for encryption
   * @type {string}
   * @memberof DocumentUploadRequest
   */
  encryptionKey?: string;
}
/**
 *
 * @export
 * @interface DocumentUploadResponse
 */
export interface DocumentUploadResponse {
  /**
   *
   * @type {string}
   * @memberof DocumentUploadResponse
   */
  documentId: string;
  /**
   * Key used for encryption
   * @type {string}
   * @memberof DocumentUploadResponse
   */
  encryptionKey: string;
}
/**
 *
 * @export
 * @interface EncryptedDocumentObject
 */
export interface EncryptedDocumentObject {
  /**
   *
   * @type {EncryptedDocumentObjectDocument}
   * @memberof EncryptedDocumentObject
   */
  document: EncryptedDocumentObjectDocument;
}
/**
 *
 * @export
 * @interface EncryptedDocumentObjectDocument
 */
export interface EncryptedDocumentObjectDocument {
  /**
   * Encrypted verifiable credential
   * @type {string}
   * @memberof EncryptedDocumentObjectDocument
   */
  cipherText: string;
  /**
   * Initialisation vector
   * @type {string}
   * @memberof EncryptedDocumentObjectDocument
   */
  iv: string;
  /**
   * Message authentication code (MAC)
   * @type {string}
   * @memberof EncryptedDocumentObjectDocument
   */
  tag: string;
  /**
   * Encryption algorithm identifier (OA)
   * @type {string}
   * @memberof EncryptedDocumentObjectDocument
   */
  type: string;
}
/**
 * An object containing references to the source of an error.
 * @export
 * @interface ErrorSource
 */
export interface ErrorSource {
  /**
   * A JSON Pointer which describes which property in the request object to which an error message relates.  For more details on JSON pointers see [RFC6901](https://tools.ietf.org/html/rfc6901).
   * @type {string}
   * @memberof ErrorSource
   */
  pointer?: string;
  /**
   * Describes the location of the data to which the error message is related.  - **\"REQUEST\"** - Indicates the message relates to a _property_ within the request   object. The `pointer` property should be populated in this case. - **\"QUERY\"** - Indicates the message relates to a _query_ parameter. The `parameter`   property should be populated in this case. - **\"ID\"** - Indicates the message relates to the identifier of the REST resource. The   `parameter` property _may optionally_ be populated in this case.
   * @type {string}
   * @memberof ErrorSource
   */
  location?: ErrorSourceLocationEnum;
  /**
   * A string indicating which URI query parameter caused the error.
   * @type {string}
   * @memberof ErrorSource
   */
  parameter?: string;
}

export const ErrorSourceLocationEnum = {
  Request: 'REQUEST',
  Query: 'QUERY',
  Id: 'ID',
} as const;

export type ErrorSourceLocationEnum =
  typeof ErrorSourceLocationEnum[keyof typeof ErrorSourceLocationEnum];

/**
 * A schema for the `errors` array.
 * @export
 * @interface ErrorsArray
 */
export interface ErrorsArray {
  /**
   *
   * @type {Array<Error>}
   * @memberof ErrorsArray
   */
  errors?: Array<Error>;
}
/**
 * The response returned when one or more errors have been encountered.
 * @export
 * @interface ErrorsResponseSchema
 */
export interface ErrorsResponseSchema {
  /**
   *
   * @type {Array<Error>}
   * @memberof ErrorsResponseSchema
   */
  errors: Array<Error>;
}
/**
 * get keypair response
 * @export
 * @interface GetKeyPairResponse
 */
export interface GetKeyPairResponse {
  /**
   * key pair id
   * @type {string}
   * @memberof GetKeyPairResponse
   */
  keyId: string;
  /**
   * key pair name
   * @type {string}
   * @memberof GetKeyPairResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GetKeyPairResponse
   */
  publickey?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetKeyPairResponse
   */
  disabled?: boolean;
}
/**
 *
 * @export
 * @interface GetKeyPairResponseAllOf
 */
export interface GetKeyPairResponseAllOf {
  /**
   *
   * @type {string}
   * @memberof GetKeyPairResponseAllOf
   */
  publickey?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetKeyPairResponseAllOf
   */
  disabled?: boolean;
}
/**
 *
 * @export
 * @interface GetRevocationList200Response
 */
export interface GetRevocationList200Response {
  /**
   * The JSON-LD context of the credential.
   * @type {Array<string>}
   * @memberof GetRevocationList200Response
   */
  '@context': Array<string>;
  /**
   * The ID of the credential.
   * @type {string}
   * @memberof GetRevocationList200Response
   */
  id?: string;
  /**
   * The JSON-LD type of the credential.
   * @type {Array<string>}
   * @memberof GetRevocationList200Response
   */
  type: Array<string>;
  /**
   * The issuanceDate
   * @type {string}
   * @memberof GetRevocationList200Response
   */
  issuanceDate: string;
  /**
   * The expirationDate
   * @type {string}
   * @memberof GetRevocationList200Response
   */
  expirationDate?: string;
  /**
   * The subject
   * @type {object}
   * @memberof GetRevocationList200Response
   */
  credentialSubject: object;
  /**
   *
   * @type {Issuer}
   * @memberof GetRevocationList200Response
   */
  issuer: Issuer;
  /**
   *
   * @type {LinkedDataProof}
   * @memberof GetRevocationList200Response
   */
  proof?: LinkedDataProof;
}
/**
 *
 * @export
 * @interface GetRevocationLists200Response
 */
export interface GetRevocationLists200Response {
  /**
   *
   * @type {string}
   * @memberof GetRevocationLists200Response
   */
  documentHash?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetRevocationLists200Response
   */
  revoked?: boolean;
}
/**
 *
 * @export
 * @interface IssueCredentialRequest
 */
export interface IssueCredentialRequest {
  /**
   *
   * @type {string}
   * @memberof IssueCredentialRequest
   */
  signingMethod?: IssueCredentialRequestSigningMethodEnum;
  /**
   *
   * @type {Credential}
   * @memberof IssueCredentialRequest
   */
  credential: Credential;
}

export const IssueCredentialRequestSigningMethodEnum = {
  Svip: 'SVIP',
  Oa: 'OA',
} as const;

export type IssueCredentialRequestSigningMethodEnum =
  typeof IssueCredentialRequestSigningMethodEnum[keyof typeof IssueCredentialRequestSigningMethodEnum];

/**
 *
 * @export
 * @interface IssueCredentialResponse
 */
export interface IssueCredentialResponse {
  /**
   *
   * @type {VerifiableCredential}
   * @memberof IssueCredentialResponse
   */
  verifiableCredential?: VerifiableCredential;
}
/**
 * @type Issuer
 * A JSON-LD Verifiable Credential Issuer.
 * @export
 */
export type Issuer = IssuerOneOf | string;

/**
 *
 * @export
 * @interface IssuerOneOf
 */
export interface IssuerOneOf {
  /**
   *
   * @type {string}
   * @memberof IssuerOneOf
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof IssuerOneOf
   */
  name?: string;
}
/**
 * keypair object
 * @export
 * @interface KeyPair
 */
export interface KeyPair {
  /**
   * key pair id
   * @type {string}
   * @memberof KeyPair
   */
  keyId: string;
  /**
   * key pair name
   * @type {string}
   * @memberof KeyPair
   */
  name: string;
}
/**
 * A JSON-LD Linked Data proof.
 * @export
 * @interface LinkedDataProof
 */
export interface LinkedDataProof {
  /**
   * Linked Data Signature Suite used to produce proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  type?: string;
  /**
   * Date the proof was created.
   * @type {string}
   * @memberof LinkedDataProof
   */
  created?: string;
  /**
   * A value chosen by the verifier to mitigate authentication proof replay attacks.
   * @type {string}
   * @memberof LinkedDataProof
   */
  challenge?: string;
  /**
   * The domain of the proof to restrict its use to a particular target.
   * @type {string}
   * @memberof LinkedDataProof
   */
  domain?: string;
  /**
   * A value chosen by the creator of a proof to randomize proof values for privacy purposes.
   * @type {string}
   * @memberof LinkedDataProof
   */
  nonce?: string;
  /**
   * Verification Method used to verify proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  verificationMethod?: string;
  /**
   * The purpose of the proof to be used with verificationMethod.
   * @type {string}
   * @memberof LinkedDataProof
   */
  proofPurpose?: string;
  /**
   * Detached JSON Web Signature.
   * @type {string}
   * @memberof LinkedDataProof
   */
  jws?: string;
  /**
   * Value of the Linked Data proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  proofValue?: string;
}
/**
 * list keypair response
 * @export
 * @interface ListKeyPairResponse
 */
export interface ListKeyPairResponse {
  /**
   *
   * @type {Array<KeyPair>}
   * @memberof ListKeyPairResponse
   */
  results?: Array<KeyPair>;
}
/**
 * An object containing the details of a particular error.
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * A unique identifier for the error occurrence, to provide traceability in application logs.
   * @type {string}
   * @memberof ModelError
   */
  id?: string;
  /**
   * A provider-specific or enterprise defined error code. Codes must be in uppercase.
   * @type {string}
   * @memberof ModelError
   */
  code: string;
  /**
   * A provider-specific or enterprise defined error message.
   * @type {string}
   * @memberof ModelError
   */
  detail: string;
  /**
   *
   * @type {ErrorSource}
   * @memberof ModelError
   */
  source?: ErrorSource;
  /**
   * A URL which leads to further details about the error (e.g. A help page).
   * @type {string}
   * @memberof ModelError
   */
  helpUrl?: string;
  /**
   * Help text which can provide further assistance on the error.
   * @type {string}
   * @memberof ModelError
   */
  helpText?: string;
}
/**
 *
 * @export
 * @interface OARevocationStatus
 */
export interface OARevocationStatus {
  /**
   *
   * @type {string}
   * @memberof OARevocationStatus
   */
  documentHash?: string;
  /**
   *
   * @type {boolean}
   * @memberof OARevocationStatus
   */
  revoked?: boolean;
}
/**
 * Pagination data object
 * @export
 * @interface Pagination
 */
export interface Pagination {
  /**
   *
   * @type {string}
   * @memberof Pagination
   */
  nextCursor?: string | null;
  /**
   *
   * @type {string}
   * @memberof Pagination
   */
  prevCursor?: string | null;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  limit?: number;
}
/**
 *
 * @export
 * @interface SetStatusRequest
 */
export interface SetStatusRequest {
  /**
   *
   * @type {string}
   * @memberof SetStatusRequest
   */
  credentialId: string;
  /**
   *
   * @type {Array<CredentialStatus>}
   * @memberof SetStatusRequest
   */
  credentialStatus: Array<CredentialStatus>;
}
/**
 *
 * @export
 * @interface ValidateCredentialRequest
 */
export interface ValidateCredentialRequest {
  /**
   *
   * @type {string}
   * @memberof ValidateCredentialRequest
   */
  schemaType: string;
  /**
   *
   * @type {VerifiableCredential}
   * @memberof ValidateCredentialRequest
   */
  verifiableCredential: VerifiableCredential;
}
/**
 * A JSON-LD Verifiable Credential with a proof.
 * @export
 * @interface VerifiableCredential
 */
export interface VerifiableCredential {
  /**
   * The JSON-LD context of the credential.
   * @type {Array<string>}
   * @memberof VerifiableCredential
   */
  '@context': Array<string>;
  /**
   * The ID of the credential.
   * @type {string}
   * @memberof VerifiableCredential
   */
  id?: string;
  /**
   * The JSON-LD type of the credential.
   * @type {Array<string>}
   * @memberof VerifiableCredential
   */
  type: Array<string>;
  /**
   * The issuanceDate
   * @type {string}
   * @memberof VerifiableCredential
   */
  issuanceDate: string;
  /**
   * The expirationDate
   * @type {string}
   * @memberof VerifiableCredential
   */
  expirationDate?: string;
  /**
   * The subject
   * @type {object}
   * @memberof VerifiableCredential
   */
  credentialSubject: object;
  /**
   *
   * @type {Issuer}
   * @memberof VerifiableCredential
   */
  issuer: Issuer;
  /**
   *
   * @type {LinkedDataProof}
   * @memberof VerifiableCredential
   */
  proof?: LinkedDataProof;
}
/**
 *
 * @export
 * @interface VerifiableCredentialAllOf
 */
export interface VerifiableCredentialAllOf {
  /**
   *
   * @type {LinkedDataProof}
   * @memberof VerifiableCredentialAllOf
   */
  proof?: LinkedDataProof;
}
/**
 * Object summarizing a verification
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
  /**
   * The checks performed
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  checks?: Array<string>;
  /**
   * Warnings
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  warnings?: Array<string>;
  /**
   * Errors
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface VerifyCredentialRequest
 */
export interface VerifyCredentialRequest {
  /**
   *
   * @type {VerifiableCredential}
   * @memberof VerifyCredentialRequest
   */
  verifiableCredential?: VerifiableCredential;
}

/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List all the issued credentials
     * @summary List all the issued credentials
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentials: async (
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      sort?: 'asc' | 'desc',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/credentials`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (prevCursor !== undefined) {
        localVarQueryParameter['prevCursor'] = prevCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} listId The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationList: async (
      listId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      assertParamExists('getRevocationList', 'listId', listId);
      const localVarPath =
        `/credentials/status/revocation-list-2020/{listId}`.replace(
          `{${'listId'}}`,
          encodeURIComponent(String(listId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} documentHash The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationLists: async (
      documentHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'documentHash' is not null or undefined
      assertParamExists('getRevocationLists', 'documentHash', documentHash);
      const localVarPath = `/credentials/status/oa-ocsp/{documentHash}`.replace(
        `{${'documentHash'}}`,
        encodeURIComponent(String(documentHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {IssueCredentialRequest} [issueCredentialRequest] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueCredential: async (
      issueCredentialRequest?: IssueCredentialRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/credentials/issue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        issueCredentialRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the status of a verifiable credential
     * @summary Sets the status of a verifiable credential
     * @param {SetStatusRequest} [setStatusRequest] Parameters for setting the status of the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCredentialStatus: async (
      setStatusRequest?: SetStatusRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/credentials/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setStatusRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validates the credentialSubject and returns any errors in the response body.
     * @summary Validates the credentialSubject and returns any errors in the response body.
     * @param {ValidateCredentialRequest} [validateCredentialRequest] Parameters for validating a credentialSubject.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateCredential: async (
      validateCredentialRequest?: ValidateCredentialRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/credentials/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        validateCredentialRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [verifyCredentialRequest] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredential: async (
      verifyCredentialRequest?: VerifyCredentialRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/credentials/verify`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyCredentialRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CredentialsApiAxiosParamCreator(configuration);
  return {
    /**
     * List all the issued credentials
     * @summary List all the issued credentials
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredentials(
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      sort?: 'asc' | 'desc',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCredentials(
        nextCursor,
        prevCursor,
        limit,
        q,
        sort,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} listId The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevocationList(
      listId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRevocationList200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationList(listId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} documentHash The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevocationLists(
      documentHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetRevocationLists200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationLists(
          documentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {IssueCredentialRequest} [issueCredentialRequest] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueCredential(
      issueCredentialRequest?: IssueCredentialRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IssueCredentialResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issueCredential(
        issueCredentialRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Sets the status of a verifiable credential
     * @summary Sets the status of a verifiable credential
     * @param {SetStatusRequest} [setStatusRequest] Parameters for setting the status of the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCredentialStatus(
      setStatusRequest?: SetStatusRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setCredentialStatus(
          setStatusRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Validates the credentialSubject and returns any errors in the response body.
     * @summary Validates the credentialSubject and returns any errors in the response body.
     * @param {ValidateCredentialRequest} [validateCredentialRequest] Parameters for validating a credentialSubject.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateCredential(
      validateCredentialRequest?: ValidateCredentialRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateCredential(
          validateCredentialRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [verifyCredentialRequest] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyCredential(
      verifyCredentialRequest?: VerifyCredentialRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<VerificationResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifyCredential(
          verifyCredentialRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CredentialsApiFp(configuration);
  return {
    /**
     * List all the issued credentials
     * @summary List all the issued credentials
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentials(
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      sort?: 'asc' | 'desc',
      options?: any
    ): AxiosPromise<CredentialsResponse> {
      return localVarFp
        .getCredentials(nextCursor, prevCursor, limit, q, sort, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} listId The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationList(
      listId: string,
      options?: any
    ): AxiosPromise<GetRevocationList200Response> {
      return localVarFp
        .getRevocationList(listId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get revocation list by ID
     * @param {string} documentHash The revocation list ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationLists(
      documentHash: string,
      options?: any
    ): AxiosPromise<GetRevocationLists200Response> {
      return localVarFp
        .getRevocationLists(documentHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {IssueCredentialRequest} [issueCredentialRequest] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueCredential(
      issueCredentialRequest?: IssueCredentialRequest,
      options?: any
    ): AxiosPromise<IssueCredentialResponse> {
      return localVarFp
        .issueCredential(issueCredentialRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the status of a verifiable credential
     * @summary Sets the status of a verifiable credential
     * @param {SetStatusRequest} [setStatusRequest] Parameters for setting the status of the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCredentialStatus(
      setStatusRequest?: SetStatusRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setCredentialStatus(setStatusRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validates the credentialSubject and returns any errors in the response body.
     * @summary Validates the credentialSubject and returns any errors in the response body.
     * @param {ValidateCredentialRequest} [validateCredentialRequest] Parameters for validating a credentialSubject.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateCredential(
      validateCredentialRequest?: ValidateCredentialRequest,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .validateCredential(validateCredentialRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [verifyCredentialRequest] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredential(
      verifyCredentialRequest?: VerifyCredentialRequest,
      options?: any
    ): AxiosPromise<VerificationResult> {
      return localVarFp
        .verifyCredential(verifyCredentialRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CredentialsApi - interface
 * @export
 * @interface CredentialsApi
 */
export interface CredentialsApiInterface {
  /**
   * List all the issued credentials
   * @summary List all the issued credentials
   * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
   * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
   * @param {number} [limit] The numbers of items to return
   * @param {string} [q] Searches for the query string in the searchable fields
   * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  getCredentials(
    nextCursor?: string,
    prevCursor?: string,
    limit?: number,
    q?: string,
    sort?: 'asc' | 'desc',
    options?: AxiosRequestConfig
  ): AxiosPromise<CredentialsResponse>;

  /**
   *
   * @summary Get revocation list by ID
   * @param {string} listId The revocation list ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  getRevocationList(
    listId: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetRevocationList200Response>;

  /**
   *
   * @summary Get revocation list by ID
   * @param {string} documentHash The revocation list ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  getRevocationLists(
    documentHash: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetRevocationLists200Response>;

  /**
   * Issues a credential and returns it in the response body.
   * @summary Issues a credential and returns it in the response body.
   * @param {IssueCredentialRequest} [issueCredentialRequest] Parameters for issuing the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  issueCredential(
    issueCredentialRequest?: IssueCredentialRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<IssueCredentialResponse>;

  /**
   * Sets the status of a verifiable credential
   * @summary Sets the status of a verifiable credential
   * @param {SetStatusRequest} [setStatusRequest] Parameters for setting the status of the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  setCredentialStatus(
    setStatusRequest?: SetStatusRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   * Validates the credentialSubject and returns any errors in the response body.
   * @summary Validates the credentialSubject and returns any errors in the response body.
   * @param {ValidateCredentialRequest} [validateCredentialRequest] Parameters for validating a credentialSubject.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  validateCredential(
    validateCredentialRequest?: ValidateCredentialRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<object>;

  /**
   * Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @param {VerifyCredentialRequest} [verifyCredentialRequest] Parameters for verifying a verifiableCredential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApiInterface
   */
  verifyCredential(
    verifyCredentialRequest?: VerifyCredentialRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<VerificationResult>;
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI implements CredentialsApiInterface {
  /**
   * List all the issued credentials
   * @summary List all the issued credentials
   * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
   * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
   * @param {number} [limit] The numbers of items to return
   * @param {string} [q] Searches for the query string in the searchable fields
   * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public getCredentials(
    nextCursor?: string,
    prevCursor?: string,
    limit?: number,
    q?: string,
    sort?: 'asc' | 'desc',
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .getCredentials(nextCursor, prevCursor, limit, q, sort, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get revocation list by ID
   * @param {string} listId The revocation list ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public getRevocationList(listId: string, options?: AxiosRequestConfig) {
    return CredentialsApiFp(this.configuration)
      .getRevocationList(listId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get revocation list by ID
   * @param {string} documentHash The revocation list ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public getRevocationLists(
    documentHash: string,
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .getRevocationLists(documentHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Issues a credential and returns it in the response body.
   * @summary Issues a credential and returns it in the response body.
   * @param {IssueCredentialRequest} [issueCredentialRequest] Parameters for issuing the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public issueCredential(
    issueCredentialRequest?: IssueCredentialRequest,
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .issueCredential(issueCredentialRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the status of a verifiable credential
   * @summary Sets the status of a verifiable credential
   * @param {SetStatusRequest} [setStatusRequest] Parameters for setting the status of the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public setCredentialStatus(
    setStatusRequest?: SetStatusRequest,
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .setCredentialStatus(setStatusRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validates the credentialSubject and returns any errors in the response body.
   * @summary Validates the credentialSubject and returns any errors in the response body.
   * @param {ValidateCredentialRequest} [validateCredentialRequest] Parameters for validating a credentialSubject.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public validateCredential(
    validateCredentialRequest?: ValidateCredentialRequest,
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .validateCredential(validateCredentialRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @param {VerifyCredentialRequest} [verifyCredentialRequest] Parameters for verifying a verifiableCredential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public verifyCredential(
    verifyCredentialRequest?: VerifyCredentialRequest,
    options?: AxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .verifyCredential(verifyCredentialRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get encrypted document by Id
     * @param {string} documentId The encrypted documents object Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocument: async (
      documentId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'documentId' is not null or undefined
      assertParamExists('getDocument', 'documentId', documentId);
      const localVarPath = `/storage/documents/{documentId}`.replace(
        `{${'documentId'}}`,
        encodeURIComponent(String(documentId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary encrypt and upload document
     * @param {DocumentUploadRequest} [documentUploadRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadDocument: async (
      documentUploadRequest?: DocumentUploadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/storage/documents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentUploadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get encrypted document by Id
     * @param {string} documentId The encrypted documents object Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDocument(
      documentId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EncryptedDocumentObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(
        documentId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary encrypt and upload document
     * @param {DocumentUploadRequest} [documentUploadRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadDocument(
      documentUploadRequest?: DocumentUploadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DocumentUploadResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocument(
        documentUploadRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary Get encrypted document by Id
     * @param {string} documentId The encrypted documents object Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocument(
      documentId: string,
      options?: any
    ): AxiosPromise<EncryptedDocumentObject> {
      return localVarFp
        .getDocument(documentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary encrypt and upload document
     * @param {DocumentUploadRequest} [documentUploadRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadDocument(
      documentUploadRequest?: DocumentUploadRequest,
      options?: any
    ): AxiosPromise<DocumentUploadResponse> {
      return localVarFp
        .uploadDocument(documentUploadRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @summary Get encrypted document by Id
   * @param {string} documentId The encrypted documents object Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getDocument(
    documentId: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<EncryptedDocumentObject>;

  /**
   *
   * @summary encrypt and upload document
   * @param {DocumentUploadRequest} [documentUploadRequest] Parameters uploading the document
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  uploadDocument(
    documentUploadRequest?: DocumentUploadRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<DocumentUploadResponse>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @summary Get encrypted document by Id
   * @param {string} documentId The encrypted documents object Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getDocument(documentId: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getDocument(documentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary encrypt and upload document
   * @param {DocumentUploadRequest} [documentUploadRequest] Parameters uploading the document
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public uploadDocument(
    documentUploadRequest?: DocumentUploadRequest,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .uploadDocument(documentUploadRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DocumentSchemaApi - axios parameter creator
 * @export
 */
export const DocumentSchemaApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List document schemas
     * @summary List document schemas
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {string} [name] filter by schema name
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentSchemas: async (
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      name?: string,
      sort?: 'asc' | 'desc',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/document-schemas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      if (nextCursor !== undefined) {
        localVarQueryParameter['nextCursor'] = nextCursor;
      }

      if (prevCursor !== undefined) {
        localVarQueryParameter['prevCursor'] = prevCursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DocumentSchemaApi - functional programming interface
 * @export
 */
export const DocumentSchemaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DocumentSchemaApiAxiosParamCreator(configuration);
  return {
    /**
     * List document schemas
     * @summary List document schemas
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {string} [name] filter by schema name
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDocumentSchemas(
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      name?: string,
      sort?: 'asc' | 'desc',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DocumentSchemasResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDocumentSchemas(
          nextCursor,
          prevCursor,
          limit,
          q,
          name,
          sort,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DocumentSchemaApi - factory interface
 * @export
 */
export const DocumentSchemaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DocumentSchemaApiFp(configuration);
  return {
    /**
     * List document schemas
     * @summary List document schemas
     * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
     * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
     * @param {number} [limit] The numbers of items to return
     * @param {string} [q] Searches for the query string in the searchable fields
     * @param {string} [name] filter by schema name
     * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentSchemas(
      nextCursor?: string,
      prevCursor?: string,
      limit?: number,
      q?: string,
      name?: string,
      sort?: 'asc' | 'desc',
      options?: any
    ): AxiosPromise<DocumentSchemasResponse> {
      return localVarFp
        .getDocumentSchemas(
          nextCursor,
          prevCursor,
          limit,
          q,
          name,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DocumentSchemaApi - interface
 * @export
 * @interface DocumentSchemaApi
 */
export interface DocumentSchemaApiInterface {
  /**
   * List document schemas
   * @summary List document schemas
   * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
   * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
   * @param {number} [limit] The numbers of items to return
   * @param {string} [q] Searches for the query string in the searchable fields
   * @param {string} [name] filter by schema name
   * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentSchemaApiInterface
   */
  getDocumentSchemas(
    nextCursor?: string,
    prevCursor?: string,
    limit?: number,
    q?: string,
    name?: string,
    sort?: 'asc' | 'desc',
    options?: AxiosRequestConfig
  ): AxiosPromise<DocumentSchemasResponse>;
}

/**
 * DocumentSchemaApi - object-oriented interface
 * @export
 * @class DocumentSchemaApi
 * @extends {BaseAPI}
 */
export class DocumentSchemaApi
  extends BaseAPI
  implements DocumentSchemaApiInterface
{
  /**
   * List document schemas
   * @summary List document schemas
   * @param {string} [nextCursor] Starting key for the next result set. If you don\&#39;t pass a nextCursor parameter, but do pass a limit parameter, the default value retrieves the first portion (or \&quot;page\&quot;) of results.
   * @param {string} [prevCursor] Starting key for the previous result set. If you pass prevCursor and nextCursor together, nextCursor takes precedence
   * @param {number} [limit] The numbers of items to return
   * @param {string} [q] Searches for the query string in the searchable fields
   * @param {string} [name] filter by schema name
   * @param {'asc' | 'desc'} [sort] The supported sort directions are either &#x60;asc&#x60; for ascending or &#x60;desc&#x60; for descending. If a sort direction is not specified, then order will default to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentSchemaApi
   */
  public getDocumentSchemas(
    nextCursor?: string,
    prevCursor?: string,
    limit?: number,
    q?: string,
    name?: string,
    sort?: 'asc' | 'desc',
    options?: AxiosRequestConfig
  ) {
    return DocumentSchemaApiFp(this.configuration)
      .getDocumentSchemas(nextCursor, prevCursor, limit, q, name, sort, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * KeyPairApi - axios parameter creator
 * @export
 */
export const KeyPairApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary creates a JWK public/private signing keypair that can be used to sign the credentials
     * @param {CreateKeyPairRequest} [createKeyPairRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKeyPair: async (
      createKeyPairRequest?: CreateKeyPairRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/keypairs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createKeyPairRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary delete a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKeyPair: async (
      keyId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyId' is not null or undefined
      assertParamExists('deleteKeyPair', 'keyId', keyId);
      const localVarPath = `/keypairs/{keyId}`.replace(
        `{${'keyId'}}`,
        encodeURIComponent(String(keyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary disable a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableKeyPair: async (
      keyId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyId' is not null or undefined
      assertParamExists('disableKeyPair', 'keyId', keyId);
      const localVarPath = `/keypairs/{keyId}/disable`.replace(
        `{${'keyId'}}`,
        encodeURIComponent(String(keyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeyPair: async (
      keyId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyId' is not null or undefined
      assertParamExists('getKeyPair', 'keyId', keyId);
      const localVarPath = `/keypairs/{keyId}`.replace(
        `{${'keyId'}}`,
        encodeURIComponent(String(keyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary return list of keys pairs
     * @param {boolean} [includeDisabled] Include disabled key pairs in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeyPairs: async (
      includeDisabled?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/keypairs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorizer required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      );

      if (includeDisabled !== undefined) {
        localVarQueryParameter['includeDisabled'] = includeDisabled;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * KeyPairApi - functional programming interface
 * @export
 */
export const KeyPairApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = KeyPairApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary creates a JWK public/private signing keypair that can be used to sign the credentials
     * @param {CreateKeyPairRequest} [createKeyPairRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createKeyPair(
      createKeyPairRequest?: CreateKeyPairRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateKeyPairResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createKeyPair(
        createKeyPairRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary delete a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteKeyPair(
      keyId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKeyPair(
        keyId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary disable a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disableKeyPair(
      keyId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.disableKeyPair(
        keyId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary get a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeyPair(
      keyId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKeyPairResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyPair(
        keyId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary return list of keys pairs
     * @param {boolean} [includeDisabled] Include disabled key pairs in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listKeyPairs(
      includeDisabled?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListKeyPairResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listKeyPairs(
        includeDisabled,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * KeyPairApi - factory interface
 * @export
 */
export const KeyPairApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = KeyPairApiFp(configuration);
  return {
    /**
     *
     * @summary creates a JWK public/private signing keypair that can be used to sign the credentials
     * @param {CreateKeyPairRequest} [createKeyPairRequest] Parameters uploading the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKeyPair(
      createKeyPairRequest?: CreateKeyPairRequest,
      options?: any
    ): AxiosPromise<CreateKeyPairResponse> {
      return localVarFp
        .createKeyPair(createKeyPairRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary delete a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKeyPair(keyId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteKeyPair(keyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary disable a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableKeyPair(keyId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .disableKeyPair(keyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get a key pair
     * @param {string} keyId Key pair id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeyPair(keyId: string, options?: any): AxiosPromise<GetKeyPairResponse> {
      return localVarFp
        .getKeyPair(keyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary return list of keys pairs
     * @param {boolean} [includeDisabled] Include disabled key pairs in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeyPairs(
      includeDisabled?: boolean,
      options?: any
    ): AxiosPromise<ListKeyPairResponse> {
      return localVarFp
        .listKeyPairs(includeDisabled, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * KeyPairApi - interface
 * @export
 * @interface KeyPairApi
 */
export interface KeyPairApiInterface {
  /**
   *
   * @summary creates a JWK public/private signing keypair that can be used to sign the credentials
   * @param {CreateKeyPairRequest} [createKeyPairRequest] Parameters uploading the document
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApiInterface
   */
  createKeyPair(
    createKeyPairRequest?: CreateKeyPairRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<CreateKeyPairResponse>;

  /**
   *
   * @summary delete a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApiInterface
   */
  deleteKeyPair(
    keyId: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary disable a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApiInterface
   */
  disableKeyPair(
    keyId: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary get a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApiInterface
   */
  getKeyPair(
    keyId: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetKeyPairResponse>;

  /**
   *
   * @summary return list of keys pairs
   * @param {boolean} [includeDisabled] Include disabled key pairs in the response
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApiInterface
   */
  listKeyPairs(
    includeDisabled?: boolean,
    options?: AxiosRequestConfig
  ): AxiosPromise<ListKeyPairResponse>;
}

/**
 * KeyPairApi - object-oriented interface
 * @export
 * @class KeyPairApi
 * @extends {BaseAPI}
 */
export class KeyPairApi extends BaseAPI implements KeyPairApiInterface {
  /**
   *
   * @summary creates a JWK public/private signing keypair that can be used to sign the credentials
   * @param {CreateKeyPairRequest} [createKeyPairRequest] Parameters uploading the document
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApi
   */
  public createKeyPair(
    createKeyPairRequest?: CreateKeyPairRequest,
    options?: AxiosRequestConfig
  ) {
    return KeyPairApiFp(this.configuration)
      .createKeyPair(createKeyPairRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary delete a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApi
   */
  public deleteKeyPair(keyId: string, options?: AxiosRequestConfig) {
    return KeyPairApiFp(this.configuration)
      .deleteKeyPair(keyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary disable a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApi
   */
  public disableKeyPair(keyId: string, options?: AxiosRequestConfig) {
    return KeyPairApiFp(this.configuration)
      .disableKeyPair(keyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get a key pair
   * @param {string} keyId Key pair id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApi
   */
  public getKeyPair(keyId: string, options?: AxiosRequestConfig) {
    return KeyPairApiFp(this.configuration)
      .getKeyPair(keyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary return list of keys pairs
   * @param {boolean} [includeDisabled] Include disabled key pairs in the response
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyPairApi
   */
  public listKeyPairs(includeDisabled?: boolean, options?: AxiosRequestConfig) {
    return KeyPairApiFp(this.configuration)
      .listKeyPairs(includeDisabled, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
