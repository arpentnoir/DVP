import {
  QRPayload,
  StorageClient,
  VerifiableCredential,
} from '@dvp/api-interfaces';
import {
  getUuId,
  Logger,
  RequestInvocationContext,
  S3Adapter,
  ValidationError,
} from '@dvp/server-common';
import { encryptString, generateEncryptionKey } from '@govtechsg/oa-encryption';
import { config } from '../../config';

const DOCUMENTS_BASE_PATH = 'documents/';

/**
 * An interface that represents a document to be uploaded
 */
export interface IUploadDocument {
  storageClient: StorageClient;
  document: string;
  documentId?: string;
  encryptionKey?: string;
  encryptData?: boolean;
  overwrite?: boolean;
}

/** The S3 client to be used for document storage.  */
export const storageClient: StorageClient = S3Adapter(
  config.s3Config,
  DOCUMENTS_BASE_PATH
);

/**
 * A service class responsible for handling document storage operations.
 */
export class StorageService {
  logger: Logger;
  invocationContext: RequestInvocationContext;
  documentStorePath: string;

  constructor(invocationContext: RequestInvocationContext) {
    this.invocationContext = invocationContext;
    this.logger = Logger.from(invocationContext);
    this.documentStorePath = storageClient.getBasePath();
  }

  /**
   * Deletes a document from storage with the given documentId.
   * 
   * @param storageClient The storgage client the operation will be performed on.
   * @param documentId The documentId of the document to be deleted.
   */
  async deleteDocument(storageClient: StorageClient, documentId: string) {
    try {
      await storageClient.deleteObject(documentId);
    } catch (err: unknown) {
      this.logger.debug(
        '[StorageService.deleteDocument] Failed to delete the verifiable credential, %o',
        err
      );
      throw new Error('Failed to delete the verifiable credential');
    }
  }

  /**
   * Gets a document from storage with the given documentId.
   * 
   * @param storageClient The storgage client the operation will be performed on.
   * @param documentId The documentId of the document to be fetched.
   * @returns A promise to return a document. 
   */
  async getDocument<DocumentType>(
    storageClient: StorageClient,
    documentId: string
  ): Promise<DocumentType> {
    const documentObject = await storageClient.getObject<DocumentType>(
      documentId
    );

    return documentObject;
  }

  /**
   * Embeds a QR URL within a verifiable credential. Uses the URL returned by a call to generateQrUrl.
   * 
   * @param verifiableCredential The VC to have the URL embedded within.
   * @returns an object containing the VC with an embedded url and the relevant documentId and encryption key
   */
  embedQrUrl(verifiableCredential: VerifiableCredential) {
    try {
      const { qrUrl, id, key } = this.generateQrUrl();

      const credentialWithQrUrl = JSON.parse(
        JSON.stringify(verifiableCredential)
      ) as VerifiableCredential;

      credentialWithQrUrl.credentialSubject.links = {
        self: {
          href: qrUrl,
        },
      };

      return { credentialWithQrUrl, documentId: id, encryptionKey: key };
    } catch (err: unknown) {
      this.logger.debug(
        '[StorageService.embedQrUrl] Failed to attach QR URL to credential, %o',
        err
      );

      throw new Error('Failed to attach QR URL to credential');
    }
  }

  /**
   * Generates a QR Code URL that will be embedded within a Verifiable Credential.
   * The generated URL points to the /storage/documents/${id} endpoint, allowing the consumer to fetch the given document.
   * 
   * @param documentId Optional parameter. Generated by this function if not supplied.
   * @param encryptionKey Optional parameter. Generated by this function if not supplied.
   * @returns an object containing a QR URL, documentId and encryption key
   */
  generateQrUrl(documentId?: string, encryptionKey?: string) {
    try {
      const key = encryptionKey || generateEncryptionKey();
      const id = documentId || getUuId();

      const uri = `${config.apiURL}/storage/documents/${id}`;

      const payload: QRPayload = {
        payload: {
          uri,
          key,
        },
      };

      const qrUrl = `${config.clientURL}/verify?q=${encodeURIComponent(
        JSON.stringify(payload)
      )}`;

      return { qrUrl, id, key };
    } catch (err: unknown) {
      this.logger.debug(
        '[StorageService.generateQrUrl] Failed to generate QR URL, %o',
        err
      );

      throw new Error('Failed to generate QR URL');
    }
  }


  /**
   * Uploads a document to storage, performing encryption of the document by default. However this can be configured
   * by using the encryptData parameter.
   * 
   * Default behaviour is to throw an error if attempting to upload a document that already exists within storage,
   * however this can be configured using the overwrite parameter.
   * 
   * @param param0 
   * @returns The documentId, and, if encryption was performed, the encryption key.
   */
  async uploadDocument({
    storageClient,
    document,
    documentId,
    encryptionKey,
    encryptData = true,
    overwrite = false,
  }: IUploadDocument) {
    const key = encryptionKey || generateEncryptionKey();
    const id = documentId || getUuId();

    let payload = document;

    if (encryptData) {
      const encryptedDocument = encryptString(document, key);

      // When a VC is fetched from storage, the consumer must have the
      // corresponding key to decrypt the document
      delete encryptedDocument.key;

      payload = JSON.stringify({ document: encryptedDocument });
    }

    if (!overwrite && (await storageClient.isObjectExists(id))) {
      throw new ValidationError('documentId', id);
    }

    const documentObjectId = await storageClient.uploadObject(payload, id);

    return encryptData
      ? { documentId: documentObjectId, encryptionKey: key }
      : { documentId: documentObjectId };
  }
}
